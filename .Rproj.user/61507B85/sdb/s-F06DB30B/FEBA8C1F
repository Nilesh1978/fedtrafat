{
    "collab_server" : "",
    "contents" : "#' A file read function\n#'\n#' \\code{fars_read} function reads your data file downloaded from the\n#' \\href{https://www.nhtsa.gov/research-data/fatality-analysis-reporting-system-fars}{Fatality Analysis Reporting System}.\n#' If file you are trying to read doesn't exist on the fars database then you will get a message \\code{filename does not exist}.\n#' Any messages associated with downloading the file will be suppressed. Data will be read using the \\code{read_csv} function from the \\code{readr} package.\n#' Dataframe will be stored in \\code{tbl_df} format using the \\code{dplyr} package\n#'\n#' @param filename Path to the file containing data.\n#' @return A tibble with data.\n#' @importFrom readr read_csv\n#' @importFrom dplyr tbl_df\n#' @examples\n#' \\dontrun{\n#' fars_complete_2013 <- fars_read(\"accident_2013-csv.bz2\")\n#' }\n#' @export\nfars_read <- function(filename) {\n  if(!file.exists(filename))\n    stop(\"file '\", filename, \"' does not exist\")\n  data <- suppressMessages({\n    readr::read_csv(filename, progress = FALSE)\n  })\n  dplyr::tbl_df(data)\n}\n\n#' Create file name using year\n#'\n#' \\code{make_filename} function uses year as an argument and create file name by embedding \\code{year} given as an argument to create a file.\n#' File name is created by pasting \\code{accident} and the input year and saving it in \\code{csv.bz2} format.\n#'\n#' @param argument \\code{year} takes the year for which the data file is to be made.\n#' @return A character vector containing the complete file name of a compressed\n#'   FARS report for a given year provided to the function as an argument.\n#' @examples\n#' make_filename(2013)\n#' @export\nmake_filename <- function(year) {\n  year <- as.integer(year)\n  sprintf(\"accident_%d.csv.bz2\", year)\n}\n\n#' Read accident information by Month & Year for multiple FARS report files into a list of tibbles\n#'\n#' \\code{fars_read_years} function takes list of years as an argument, create file names, load data files,\n#' mutate year and then select month and year.  If data for any of the years has been already downloaded then that data\n#' is not imported.  Instead data from \\code{tryCatch} is used\n#'\n#' @param argument \\code{years} takes list of years as an argument.\n#' @return A list of tibbles. Each tibble contains just two columns of the original\n#' FARS data set (\\code{MONTH} and \\code{year}). Each row corresponds to a single accident.\n#' @importFrom dplyr mutate select\n#' @details\n#' This function is not designed for direct user interaction.\n#' It is a helper function for \\code{fars_summarize_years}.\n#' If any of the objects requested via input is not available as a year file\n#'  or is not coercible to integer an \"invalid year\" error message returns.\n#' @examples\n#' \\dontrun{\n#' fars_read_years(years = c(2013, 2014))\n#' }\n#' @export\nfars_read_years <- function(years) {\n  lapply(years, function(year) {\n    file <- make_filename(year)\n    tryCatch({\n      dat <- fars_read(file)\n      dplyr::mutate(dat, year = year) %>%\n        dplyr::select(MONTH, year)\n    }, error = function(e) {\n      warning(\"invalid year: \", year)\n      return(NULL)\n    })\n  })\n}\n\n#' Summarize FARS report accidents by month and year in a tibble\n#'\n#' \\code{fars_summarize_years} function takes list of years as an argument and\n#'   provide the total number of accidents by month and year.\n#' @param \\code{years} takes list of years as an argument.\n#' @return a tibble showing summary of number of accidents by month\n#'   for each input year.\n#' @inheritParams fars_read_years\n#' @importFrom dplyr bind_rows group_by summarize\n#' @importFrom tidyr spread\n#' @examples\n#' \\dontrun{\n#' fars_summarize_years(years = c(2013, 2014))\n#' }\n#' @export\nfars_summarize_years <- function(years) {\n  dat_list <- fars_read_years(years)\n  dplyr::bind_rows(dat_list) %>%\n    dplyr::group_by(year, MONTH) %>%\n    dplyr::summarize(n = n()) %>%\n    tidyr::spread(year, n)\n}\n\n#' Maps points on the state map where accidents occured\n#'\n#' \\code{fars_map_state} function takes state number and year to map points on the state map where accidents occured.\n#' @details\n#' \\code{fars_map_state} function assumes that there will be a single integer\n#'  value for state.num and single integer value for year. The implementation\n#'  do not specifically check for these constraints.\n#'\n#'  If state does not exist in queried year: a error message of \"nothing to draw:\n#'   all regions out of bounds\" apprears.\n#'\n#'  If multiple states will be entered as a vector: a warning message will appear\n#'   stating \"only the first element will be used\", on the other hand, the graph\n#'   will be created properly including all states inputted.\n#'\n#'  If an empty vector of states is inputted: an error message of \"argument is of\n#'   length zero\" wil be displayed\n#'\n#'  If a non-existing year is entered: an error message of \"Error in\n#'   fars_read(filename) :\" will be displayed.\n#'\n#'  If multiple years will be entered as a vector: an error message of\n#'   \"EXPR must be a length 1 vector\" will be displayed.\n#'\n#'  If an empty vector of years is inputted: an error message of \"argument is\n#'   of length zero\" wil be displayed\n#'\n#' @param state.num An integer representing a state as the index (between\n#'  1 and 56).\n#' @param An integer representing the year.\n#' @return This function returns a NULL object. But as a side effect a map\n#'  where dots represent accidents also appears in a seperate window.\n#' @importFrom graphics points\n#' @importFrom maps map\n#' @importFrom dplyr filter\n#' @examples\n#' \\dontrun{\n#' fars_map_state(state.num = 1, year = 2013)\n#'}\n#' @export\nfars_map_state <- function(state.num, year) {\n  filename <- make_filename(year)\n  data <- fars_read(filename)\n  state.num <- as.integer(state.num)\n\n  if(!(state.num %in% unique(data$STATE)))\n    stop(\"invalid STATE number: \", state.num)\n  data.sub <- dplyr::filter(data, STATE == state.num)\n  if(nrow(data.sub) == 0L) {\n    message(\"no accidents to plot\")\n    return(invisible(NULL))\n  }\n  is.na(data.sub$LONGITUD) <- data.sub$LONGITUD > 900\n  is.na(data.sub$LATITUDE) <- data.sub$LATITUDE > 90\n  with(data.sub, {\n    maps::map(\"state\", ylim = range(LATITUDE, na.rm = TRUE),\n              xlim = range(LONGITUD, na.rm = TRUE))\n    graphics::points(LONGITUD, LATITUDE, pch = 46)\n  })\n}\n",
    "created" : 1499628867163.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "812815656",
    "id" : "FEBA8C1F",
    "lastKnownWriteTime" : 1499636343,
    "last_content_update" : -2147483648,
    "path" : "C:/Users/nndigh/Desktop/Educational/coursera/Mastering Software Development in R/BUILDING R PACKAGES/fedtrafat/R/fars_function.R",
    "project_path" : "R/fars_function.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}